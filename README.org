* Bayesian Analysis
This is a lisp package to specify a model and calculate posterior distributions as well as
odds ratios using Bayesian statistics, most notably a simple implementation of the
Metropolis-Hastings algorithm. It is based on Gregory's excellent book on the topic [fn:1]
of Bayesian data analysis.


While this library is research quality, it is good enough for my own use -- I give, of
course, no guarantee on correctness.

** Toy problem, setup
That being said, let's say you have some spectral line data (this problem is a slightly
changed copy of a problem from [fn:1], Chapter 3) and want to answer some questions about
it. So, first we load /bayesian-analysis/ and define a package (and directory, this needs to
be adjusted for other diectory structures) to work in [fn:2].

#+BEGIN_SRC lisp :results none
(ql:quickload :bayesian-analysis)
(ql:quickload :let-plus)
(ql:quickload :iterate)
(ql:quickload :infix-math)

(defpackage #:bayesian-example
  (:use :cl :iterate :let-plus))

(in-package #:bayesian-example)

;; set to my copy of the repository to be able to easily create this document (mainly the
;; plots)
(defparameter *dir* "/home/renee/phd/src/penning-analysis.project/bayesian-analysis/")
#+END_SRC


First, define the data given in [fn:1]:

#+BEGIN_SRC lisp :results none :in-package :bayesian-example
(defparameter example-data
  '((1 1.42) (2 0.468) (3 0.762) (4 1.312) (5 2.029) (6 0.086) (7 1.249) (8 0.368)
    (9 0.657) (10 1.294) (11 0.235) (12 0.192) (13 0.269) (14 0.827) (15 0.685) (16 0.702)
    (17 0.937) (18 1.331) (19 1.772) (20 0.53) (21 0.33) (22 1.205) (23 1.613) (24 0.3)
    (25 0.046) (26 0.026) (27 0.519) (28 0.924) (29 0.23) (30 0.877) (31 0.65) (32 1.004)
    (33 0.248) (34 1.169) (35 0.915) (36 1.113) (37 1.463) (38 2.732) (39 0.571) (40 0.865)
    (41 0.849) (42 0.171) (43 1.031) (44 1.105) (45 0.344) (46 0.087) (47 0.351) (48 1.248)
    (49 0.001) (50 0.36) (51 0.497) (52 0.072) (53 1.094) (54 1.425) (55 0.283) (56 1.526)
    (57 1.174) (58 0.558) (59 1.282) (60 0.384) (61 0.12) (62 0.187) (63 0.646) (64 0.399)))
#+END_SRC

And then plot it to take a look at it (for the definition of plot see [[Useful functions]]):

#+BEGIN_SRC lisp :results output file :exports both :package :bayesian-example
(plot (:file-name "example/just-plot.png" :size "860,400")
    ("set xlabel 'channel #'" "set ylabel 'temp. [mK]'" "set xrange [1:64]"
     "set title 'Spectral data for toy problem (from Gregory, 2005)'")
  (example-data "with points pt 7 lc 7 title ''")
  (example-data "with histeps lc 7 title ''"))
#+END_SRC

#+RESULTS:
[[file:example/just-plot.png]]

Some of the questions we wanna answer are: given the data, what is the likelihood of a
signal at channel with \nu_0=37 and compare it to the likelihood of everything being
noise. 

But to do some analysis on it with the /bayesian-analysis/ package, we first need to cast
the data into a form the library understands:

#+BEGIN_SRC lisp :results none :package :bayesian-example
(ba:define-data-class toy-data (ch "channel number") (mK "temperature") () (obj (source list))
  (let ((dim (length source)))
    (setf ch (make-array dim :element-type 'double-float)
	  mK (make-array dim :element-type 'double-float))
    (iter
      (for (x y) in-sequence source with-index i)
      (setf (aref ch i) (coerce x 'double-float)
	    (aref mK i) (coerce y 'double-float)))))
#+END_SRC

/ba:define-data-class/ is a convenience macro that defines a subclass of /ba:data/ and the
methods (interface in OOP parlance) necessary to use it - specifically a method to
initialize an object of type /toy-data/ from a simple list of the form /{x, y}*/.

** Toy problem, model definition
Gregory specifies two models that he compares to each other, one where it is assumed that
there is *no line* in the data, and one where we assume there is a *line* with the following
shape:
#+BEGIN_SRC latex :results output raw graphics :file example/lineshape.png :exports results
\begin{equation*}
  f(\nu_i) = T\exp{\left\{ - \frac{(\nu_i-\nu_0)^{2}}{2\sigma^2_L} \right\}}
\end{equation*}
#+END_SRC

#+RESULTS:
[[file:example/lineshape.png]]

Where it is assumed that the line has a width of \sigma_L=2ch and the line is predicted to
appear in the spectrum at around \nu_0=37. Furthermore, all channel are subject to
Gaussian noise specified to have \sigma = 1mK.

To express the model that describes a line in the data using /bayesian-analysis/, we simply
write:
#+BEGIN_SRC lisp :results none :in-package :bayesian-example
(use-package :infix-math)

(ba:define-bayesian-model (line toy-data)
    ((Τ :default 2 :prior :jeffreys :marginalize t :min 5e-2 :max 100 :sample-sigma 0.5)
     (ν₀ :default 37 :prior :uniform :marginalize t :min 1 :max 64 :sample-sigma 2.5)
     (σₗ :default ($ 2 / (log 2))))
    (:d_i=f_i+gaussian_error_1_equal_sigma :equal-sigma-parameter (sigma :default 1))
    ((νᵢ) ($ Τ * (exp (- (νᵢ - ν₀) ^ 2 / (2 * σₗ ^ 2))))))
    #+END_SRC

The model definition also specifies a choice of priors and their ranges. Here T is a scale
parameter and best described using a Jeffreys prior (see below), the rest are uniform
priors (the default). Parameters T and \nu_0 are sampled from a Gaussian proposal
distribution. The defintion of the model also specifies default values for the MCMC
samplers. All of the settings, however, can be overwritten when instantiating a model
object. We also specifiy that all data is assumed to have an error distribution that
follows a gaussian (by specifying /:d_i=f_i+gaussian_error_1_equal_sigma/) with \sigma=1.
Finally, f(\nu_i) is defined, where $ is a macro provided by /infix-math/.


** Toy problem, generating distributions
With that we can easily generate posteriors for the parameters using the
Metropolis-Hastings algorithm (with 200000 iterations).
#+BEGIN_SRC lisp :results none :package :bayesian-example
(defparameter *mcmc-result* (ba:find-optimum (make-instance 'ba:metropolis-hastings :no-iterations 200000)
					     (make-instance 'line)
					     (ba:initialize-from-source 'toy-data t)))
#+END_SRC

Let's have a look at the sampled values for T and \nu_0:

#+BEGIN_SRC lisp :results output file :exports both :package bayesian-example
(plot (:multiplot "layout 1,2" :file-name "example/sampled-values.png") ()
  ((ba:get-iteration-value-data *mcmc-result* 'Τ :every 50) "with lines lc 7 title ''"
   "set title '(every 50th) value of T sampled with MCMC'")
  ((ba:get-iteration-value-data *mcmc-result* 'ν₀ :every 50) "with lines lc 4 title ''"
   "set title '(every 50th) value of ν_0 sampled with MCMC'"))
#+END_SRC

#+RESULTS:
[[file:example/sampled-values.png]]

This seems alright, so let's see what the PDF for \nu_0 looks like and compare it to the
result arrived at when numerically integrating over the marginalized parameters (using
/ba:parameter-pdf-integrate/ which works only for a small number of parameters due to
limitations -- i.e. not using arbitrary precision -- of the used GNU scientific library
integration routine):

#+BEGIN_SRC lisp :results output file :exports both :in-package :bayesian-example
(let+ ((p-res (ba:get-parameter-results *mcmc-result* :start 2000 :no-bins 200))
       ((&slots ba:binned-data) (ba:get-parameter-info p-res 'ν₀)))
  (plot (:file-name "example/nu0.png")
      ("set title 'Posterior PDF for ν_0 when marginalizing over T'"
       "set yrange [0:1.1]"
       "set xrange [1:64]"
       "set xlabel 'Channel #'"
       "set ylabel 'P(ν_0) [arb.]'")
    ((normalize-to-one ba:binned-data)
     "with boxes lc 0 lw 0.1 fill solid 0.25 title 'MCMC result (200000 iterations)'")
    ((normalize-to-one
      (ba:parameter-pdf-integrate '(ν₀ 1 64) 200 '((Τ 5e-2 100))
				  (make-instance 'line)
				  (ba:initialize-from-source 'toy-data example-data)))
     "with lines lc 7 lw 2 dt 1 title 'Integrated result'")))
#+END_SRC

#+RESULTS:
[[file:example/nu0.png]]

This lines up well, so we are doing something right ;)

#+BEGIN_SRC lisp

(defparameter *mcmc-result-uniform*
  (ba:find-optimum (make-instance 'ba:metropolis-hastings :no-iterations 200000)
		   (make-instance 'line :temperature-prior :uniform)
		   (ba:initialize-from-source 'toy-data t)))


(let+ ((p-res (ba:get-parameter-results *mcmc-result* :start 2000 :no-bins 75))
       ((&slots ba:binned-data) (ba:get-parameter-info p-res 'temperature))
       (p-res-uniform (ba:get-parameter-results *mcmc-result-uniform* :start 2000 :no-bins 75))
       ((&slots (binned-data-uniform ba:binned-data))
	(ba:get-parameter-info p-res-uniform 'temperature)))
  (plot () ("set yrange [0:1.1]")
    ((normalize-to-one
      (ba::parameter-pdf-integrate '(temperature 1d-1 5d0) 200 '((ν₀ 1d0 64d0))
				   (make-instance 'line)
				   (ba:initialize-from-source 'toy-data t)
				   :normalize t))
     "with lines lc 7 lw 2 dt 1 title 'Integrated result'")
    ((normalize-to-one ba:binned-data) "with histeps lc 0 title 'MCMC result'")
    ((normalize-to-one
      (ba::parameter-pdf-integrate '(temperature 1d-1 5d0) 200 '((ν₀ 1d0 64d0))
				   (make-instance 'line :temperature-prior :uniform)
				   (ba:initialize-from-source 'toy-data t)
				   :normalize t))
     "with lines lc 9 lw 1.5 dt 1 title 'Integrated result -- Uniform prior'")
    ((normalize-to-one binned-data-uniform) "with histeps lc 3 title 'MCMC result -- Uniform prior'")))








(labels ((cmd (fmt-str &rest args)
	   (mgl-gnuplot:command (apply #'format nil fmt-str args))))
  (mgl-gnuplot:with-session ()
    (cmd "reset")
    (cmd "set terminal wxt enhanced font 'Georgia,8' dashed")
    (ba:plot-iteration-values
     (ba:find-optimum (make-instance 'ba:metropolis-hastings :no-iterations 100000)
		      (make-instance 'line)
		      (ba:initialize-from-source 'toy-data t))
     :every 20 :params-to-plot '(temperature)
     :other-plot-options "lc 0")
    (cmd "unset output")))



(let+ ((data (ba:initialize-from-source 'toy-data t))
       (model (make-instance 'line)))
  (plot () ()
    ((ba::parameter-pdf-integrate '(temperature 1d-1 5d0) 200 '((ν₀ 1d0 64d0))
				  model data :normalize t)
     "with lines lc 0 dt 1 title 'Uniform prior'")))









#+END_SRC

#+BEGIN_SRC lisp
(ba:define-bayesian-model (no-line toy-data) ()
    (:d_i=f_i+gaussian_error_1_equal_sigma
     :equal-sigma-parameter (sigma :default 1d0))
    ((x) 0d0))
#+END_SRC

** Useful functions
Let us define a plot macro to make life a bit easier:
#+BEGIN_SRC lisp :results none :in-package :bayesian-example
(defmacro plot ((&key file-name
		      (terminal-options "enhanced font 'Georgia,10' dashed")
		      ;; this seems to be a good value for github
		      (size "860,450")
		      multiplot)
		(&rest other-gnuplot-commands)
	&body data/options)
  (labels ((parse-cmds (cmds)
	     (iter
	       (for c in cmds)
	       (typecase c
		 (string (collect `(cmd ,c)))
		 (list (collect `(cmd ,@c)))
		 (t (error "Do not know how to handle command: ~a" c))))))
    `(labels ((cmd (fmt-str &rest args)
		(mgl-gnuplot:command (apply #'format nil fmt-str args))))
       (mgl-gnuplot:with-session ()
	 (cmd "reset")
	 ,@(if file-name
	       `((cmd "set output '~a/~a'" ,*dir* ,file-name)
		 (cmd "set terminal png size ~a ~a" ,size ,terminal-options))
	       `((cmd "set terminal wxt ~a" ,terminal-options)))
	 ,@(when multiplot (typecase multiplot
			     (string `((cmd "set multiplot ~a" ,multiplot)))
			     (t (error "Need to specify multiplot options."))))
	 ,@(parse-cmds other-gnuplot-commands)
	 ,@(if multiplot
	       (iter
		 (for data/opt in data/options)
		 (let+ (((data opt &rest other-cmds) data/opt))
		   (for options = (if opt opt "with lines lc 0 title ''"))
		   (appending (parse-cmds other-cmds))
		   (appending
		    `((mgl-gnuplot:plot* (list (mgl-gnuplot:data* ,data ,options)))))))
	       `((mgl-gnuplot:plot*
		  (list
		   ,@(iter
		       (for (data opt) in data/options)
		       (for options = (if opt opt "with lines lc 0 title ''"))
		       (collect `(mgl-gnuplot:data* ,data ,options)))))))
	 ,@(when multiplot `((cmd "unset multiplot")))
	 (cmd "unset output"))
       (format t "~a" ,file-name))))

(defun normalize-to-one (x/y-s)
  (let+ ((max (reduce #'max x/y-s :key #'second)))
    (mapcar #'(lambda (x/y) (list (first x/y) (/ (second x/y) max))) x/y-s)))



#+END_SRC


* Footnotes
[fn:1] /Bayesian Logical Data Analysis for the Physical Sciences/, Cambridge University
  Press, 2005, https://doi.org/10.1017/CBO9780511791277

[fn:2] Within a properly setup emacs + slime or sly, and given that quicklisp knows about
bayesian-analysis using for example https://github.com/deepestthought42/with-project-dir,
this org-mode file can be executed directly

